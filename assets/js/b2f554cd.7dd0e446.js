"use strict";(self.webpackChunkflom_github_io=self.webpackChunkflom_github_io||[]).push([[477],{10:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"/2019/07/30/open-api","metadata":{"permalink":"/blog/2019/07/30/open-api","source":"@site/blog/2019-07-30-open-api/index.md","title":"Open API","description":"Designing REST-APIs","date":"2019-07-30T00:00:00.000Z","formattedDate":"July 30, 2019","tags":[{"label":"OpenAPI","permalink":"/blog/tags/open-api"}],"readingTime":6.925,"hasTruncateMarker":false,"authors":[{"name":"Florian Mladitsch","title":"Software Developer","url":"https://github.com/flom","imageURL":"https://github.com/flom.png","key":"flom"}],"frontMatter":{"title":"Open API","authors":"flom","tags":["OpenAPI"]},"nextItem":{"title":"Poor Man\'s Zero Downtime Deployment in IIS","permalink":"/blog/2018/12/10/zero-downtime-iis-deployment"}},"content":"## Designing REST-APIs\\n\\nOver the years there has been many approaches to expose your service/business-layer to the outside world in a (programming) language agnostic way via APIs.\\nThe APIs could be as low-level as direct TCP/IP socket connections or more standardized (and complex) as the SOAP standard.\\nBut with on-going rise of the web the most common API approach you will find is that of a REST-API.\\nMost single page application are accessing the backend services via REST-APIs but they are also used for \'standalone\' services like weather data,\\ngithub, or even for a database (CouchDB).\\n\\nBut one disadvantage of building a REST-API is that the consumer must know all the endpoints, which methods are allowed on them,\\nand what data structure the API expects. \\nTo get this information you have more or less three possibilities:\\n\\n1. You wrote the API yourself\\n2. You ask the person who wrote it\\n3. You resort to the documentation \\n\\nBut when multiple people are relying on the REST-API the first two options are no longer working so having a documentation is the only solution.\\nBut relying on documentation brings its own problems along, for example being out of date, simply wrong or incomplete.\\nAdditionally on how the documentation is presented might vary from API to API. \\n\\n## OpenAPI Initiative (OAI)\\n\\nThe OpenAPI Initiative defines a specification on how REST-APIs are described and documented as described on their about page:\\n\\n<a href=\\"https://www.openapis.org/about\\" target=\\"_blank\\">https://www.openapis.org/about</a>\\n\\n> The OpenAPI Initiative (OAI) was created by a consortium of forward-looking industry experts who recognize the immense value of standardizing on how REST APIs are described. As an open governance structure under the Linux Foundation, the OAI is focused on creating, evolving and promoting a vendor neutral description format. SmartBear Software is donating the Swagger Specification directly to the OAI as the basis of this Open Specification. \\n\\nBefore the OAI there was (and still is) the tool ecosystem Swagger (<a href=\\"https://swagger.io/\\" target=\\"_blank\\">https://swagger.io</a>).\\nSwagger had its own specification language to specify and document REST-APIs and additionally tooling to generate documentation pages and even code stubs.\\nSwagger was taken into the OAI and it\'s Swagger specification 2.0 was renamed to the OpenAPI Specification. \\nBy now the OpenAPI Specification is at version 3.\\n\\nThe cool thing about having a standard language on how to describe the API is that it is possible to provide standardized/generated documentation and generate code for the client and server.\\nBecause I have never tried the complete workflow (write specification -> generate code -> implement business logic) with \\nthe OpenAPI Specification I wanted to do a small example project with this approach.\\n\\n## Example \'Project Management App\'\\n\\nFor the small example project I\'m doing a shitty little project management application with following features:\\n\\n- Create projects with name and deadline\\n- Add tasks to a project\\n- Delete tasks from a project\\n- Set tasks to finished\\n\\n## Writing the API specification on SwaggerHub\\n\\nThe first step is to visit <a href=\\"https://swagger.io/\\" target=\\"_blank\\">https://swagger.io</a> and sign in into *SwaggerHub*.\\n\\n![SwaggerHub Login](swagger_hub_login.png)\\n\\nAfter the login you will see your personal Hub where you can create a new API:\\n\\n![Hub Create API](hub_create_api.png)\\n\\nWith the option **Auto Mock API** Swagger will generate static mock data based on your defined endpoints and data structures.\\nUsing **Simple API** as a template gives a quick starting point for the API without having to know the OpenAPI specification.\\n\\nTo get a good overview of the specification language you can visit <a href=\\"https://app.swaggerhub.com/help/tutorials/openapi-3-tutorial\\" target=\\"_blank\\">OpenAPI 3.0 Tutorial</a>.\\nFor quickly looking up the syntax of single elements the <a href=\\"https://swagger.io/docs/specification/basic-structure/\\" target=\\"_blank\\">Specification</a> is a good starting point.\\n\\nAfter adding the endpoints for my Project Management App my endpoints look like this:\\n\\n![Project Management API](project_mgmt_api.png)\\n\\nAnd the data structures are as following:\\n\\n![Datastructures](api_datastructures.png)\\n\\nThe same example data you enter into your specification will be used for the **Auto Mock API**.\\nIf enabled, the Mock API is available under `https://virtserver.swaggerhub.com/[username]/[ProjectName]/[version]/`.\\nFor the client side code generation this url is taken as well as a fallback URL if you don\'t provide one yourself.\\n\\nBefore generating the code for client and server you should give a quick glance at the tags you defined in your specification.\\n\\n![Specification Tags](specification_tags.png)\\n\\nFor the generated documentation page all they seem to do is put your endpoints into sections (in my case *project* and *task*).\\nBut later for code generation the generator will put the sections/tags into different files/classes.\\nFor Angular this ends up being two services (project.service.ts and task.service.ts) and for the Python Flask server code two files are generated (project_controller.py and task_controller.py).\\n\\nAnother important setting is the *operationId*:\\n\\n![Specification Operation ID](specification_operation_id.png)\\n\\nThe *operationId* is used to generate the specific method names for your client/server code.\\n\\n## Downloading client code for Angular\\n\\nAfter the specification is done you can now generate the code for your front- and backend.\\nFor angular the process looks like this:\\n\\n### Download code via *Export -> ClientSDK -> typescript-angular*\\n\\n![Download Angular Client Code](download_angular_client.png)\\n\\nIn my case the files look like this:\\n\\n```text\\napi\\n+-- api.ts\\n+-- project.service.ts\\n+-- task.service.ts\\nmodel\\n+-- models.ts\\n+-- project.ts\\n+-- task.ts\\napi.module.ts\\nconfiguration.ts\\n...\\n```\\n\\nUnder `api` you will find the injectable services.\\nThe folder `model` contains the defined data structures.\\n`api.module.ts` defines the module which can be imported into your application and `configuration.ts` contains the settings like *API base URL*.\\n\\n### Add the client to you project\\n\\nAfter you copied the generated files into your project you have to import it into your app module.\\nAlso you have to add the `HttpClientModule` in order to use the services.\\n\\napp.module.ts\\n```typescript\\n@NgModule({\\n  ...\\n  imports: [\\n    ...\\n    HttpClientModule, // required by ApiModule\\n    ApiModule // generated code from SwaggerHub\\n  ],\\n  ...\\n  bootstrap: [AppComponent]\\n})\\nexport class AppModule {\\n}\\n```\\n\\nNormally it shouldn\'t be necessary to edit the generated client code.\\nBut after running the project you might see following error when running the project:\\n\\n![Angular Compile Error](angular_compile_error.png)\\n\\nThe solution for this error I found on Stackoverflow (<a href=\\"https://stackoverflow.com/questions/49840152/angular-has-no-exported-member-observable\\" target=\\"_blank\\">https://stackoverflow.com/questions/49840152/angular-has-no-exported-member-observable</a>)\\nTurns out beginning with *rxjs 6+* the import lines for `Observable` changed a little bit.\\nSo one solution is to go into your `*.service.ts` files and change the lines\\n\\n```typescript\\nimport { Observable } from \'rxjs/Observable\'; // wrong\\nimport { Observable } from \'rxjs\'; // works\\n```\\n\\nor install the package *rxjs-compat*\\n\\n```\\nnpm install rxjs-compat --save\\n```\\n\\nThe last thing you might want to change is the *API base URL*.\\nRunning the application as it is the service will send the requests against the Swagger Mock Server.\\nTo quickly overwrite the URL you can add a new entry into your `environment.ts` file and provide `BASE_PATH` with this value:\\n\\nenvironment.ts\\n```typescript\\nexport const environment = {\\n  production: false,\\n  base_path: \'http://localhost:8888\'\\n};\\n```\\n\\napp.module.ts\\n```typescript\\nimport { environment } from \'../environments/environment\';\\n\\n@NgModule({\\n  ...\\n  providers: [{\\n    provide: BASE_PATH,\\n    useValue: environment.base_path\\n  }],\\n  bootstrap: [AppComponent]\\n})\\nexport class AppModule {\\n}\\n```\\n\\n### Using the services\\n\\nThe usage of the generated services is more or less the same as if you would have written them yourself.\\nSimply inject them into your component and call the methods as defined in your specification via the *operationId*:\\n\\n```typescript\\nimport { Component, OnInit } from \'@angular/core\';\\nimport { Project, ProjectService } from \'../api\';\\n\\n@Component({\\n  selector: \'app-project-overview\',\\n  templateUrl: \'./project-overview.component.html\'\\n})\\nexport class ProjectOverviewComponent implements OnInit {\\n\\n  projects: Project[] = [];\\n\\n  constructor(private projectService: ProjectService) {\\n  }\\n\\n  ngOnInit(): void {\\n    this.projectService.listProjects()\\n      .subscribe((projects: Project[]) => {\\n        this.projects = projects;\\n      }, (error) => {\\n        console.log(\'error\', error);\\n      });\\n  }\\n}\\n```\\n\\n## Downloading server code for Python Flask \\n\\nFor the server code I won\'t go much into detail.\\nTo download it simply go to SwaggerHub and click on *Export -> Server Stub -> python-flask*:\\n\\n![Python Flask Server Stub Download](download_flask_stub.png)\\n\\nAs opposed to the client code the generated server code is not ready to use out of the box.\\nWhat it does is generate a ready-to-run application with the endpoints but with placeholders for the implementation:\\n\\nproject_controller.py\\n```python\\nimport connexion\\nimport six\\n\\nfrom swagger_server.models.project import Project  # noqa: E501\\nfrom swagger_server import util\\n\\nimport connexion\\nimport six\\n\\nfrom swagger_server.models.project import Project  # noqa: E501\\nfrom swagger_server import util\\n\\n\\ndef add_project(body=None):  # noqa: E501\\n    \\"\\"\\"adds an project\\n\\n    Adds a project # noqa: E501\\n\\n    :param body: The added project\\n    :type body: dict | bytes\\n\\n    :rtype: None\\n    \\"\\"\\"\\n    if connexion.request.is_json:\\n        body = Project.from_dict(connexion.request.get_json())  # noqa: E501\\n    return \'do some magic!\'\\n\\n# ...remaining endpoints...\\n```"},{"id":"/2018/12/10/zero-downtime-iis-deployment","metadata":{"permalink":"/blog/2018/12/10/zero-downtime-iis-deployment","source":"@site/blog/2018-12-10-zero-downtime-iis-deployment.md","title":"Poor Man\'s Zero Downtime Deployment in IIS","description":"For my side project I\'m deploying two projects (Angular Frontend and ASP.NET Core API) to a Windows Server with IIS installed.","date":"2018-12-10T00:00:00.000Z","formattedDate":"December 10, 2018","tags":[{"label":"IIS","permalink":"/blog/tags/iis"},{"label":"Windows","permalink":"/blog/tags/windows"},{"label":"DevOps","permalink":"/blog/tags/dev-ops"}],"readingTime":2.485,"hasTruncateMarker":false,"authors":[{"name":"Florian Mladitsch","title":"Software Developer","url":"https://github.com/flom","imageURL":"https://github.com/flom.png","key":"flom"}],"frontMatter":{"title":"Poor Man\'s Zero Downtime Deployment in IIS","authors":"flom","tags":["IIS","Windows","DevOps"]},"prevItem":{"title":"Open API","permalink":"/blog/2019/07/30/open-api"},"nextItem":{"title":"Angular: Synchronize component properties with URL query parameters","permalink":"/blog/2018/07/09/angular-synchronize-properties-with-url-parameters"}},"content":"For my side project I\'m deploying two projects (Angular Frontend and ASP.NET Core API) to a Windows Server with IIS installed.\\nIn my current setup each project is deployed automatically via [TeamCity](https://www.jetbrains.com/teamcity/) whenever I check\\nsomething into the master branch. \\n\\nOne way to do such a deployment is to use an build server tasks that handles the deployment to IIS (e.g. via Web Deploy).\\nWhat those tasks are basically doing is copying files (latest binaries of the application) to the physical path of the IIS site.\\nIf you enable more fancy options on those deployment tasks then this step might include taking the IIS site offline and/or deleting \\nall old files prior to deployment.\\n\\nThe problem I had with this approach is that the application is either offline during deployment or in an inconsistent state while\\nfiles are being copied to the IIS sites physical location.\\nFor my small side project I wanted to have a (nearly) zero downtime deployment in IIS.\\n\\nSo what I wanted to do is to copy my application binaries (that I want to serve via IIS) to an \'arbitrary\' folder and then tell\\nIIS to serve the application from this new folder after the copy job is done.\\n\\nThanks to **AppCmd.exe** this is actually pretty easy to achieve. \\n**AppCmd.exe** allows you to manage your IIS Server via command line.\\nA introduction and more complete documentation can be found here: <https://docs.microsoft.com/en-us/iis/get-started/getting-started-with-iis/getting-started-with-appcmdexe>.\\n\\nThe initial state of the folder structure looked something like this:\\n\\n```text\\nedrinks-webapp\\n+-- release_0\\n|   +-- index.html\\n|   +-- app.js\\n```\\n\\nIn each deployment I\'m creating a new folder called *release_x* where a simple task is copying the application into it\\nwhile increasing a counter (handled by TeamCity variables):\\n\\n```text\\nedrinks-webapp\\n+-- release_0\\n|   +-- index.html\\n|   +-- app.js\\n+-- release_1\\n|   +-- index.html\\n|   +--app.js\\n```\\n\\nAfter the files have been copied I call AppCmd.exe to change the folder from where the IIS page is served from:\\n\\n```shell\\n\\nC:\\\\Windows\\\\System32\\\\inetsrv\\\\appcmd.exe set vdir \\"E-Drinks/\\" -physicalPath:\\"edrinks-webapp\\\\release_1\\"\\n\\n```\\n\\n```vdir \\"E-Drinks/\\"``` identifies the application name given in IIS and ```-physicalPath:\\"...\\"``` is the actual location\\non the hard drive.\\n\\n\\nThis process goes on for each each deployment:\\n\\n```text\\nedrinks-webapp\\n+-- release_0\\n|   +-- index.html\\n|   +-- app.js\\n+-- release_1\\n|   +-- index.html\\n|   +--app.js\\n+-- release_2\\n|   +-- index.html\\n|   +-- app.js\\n|   +-- new_app.css\\n+-- release_x\\n|   +-- index.html\\n|   +-- ...\\n```\\n\\nIn order to prevent having too many old application versions I execute a small cleanup task which keeps the last *x* \\nversions and deletes the remaining old versions.\\nIn my case this is done with following python script:\\n\\n```python\\nimport os, sys, shutil\\n\\ndef cleanup(keep):\\n    print(\'keep last {} versions\'.format(keep))\\n    releases = []\\n    for item in os.listdir():\\n        if item.startswith(\'release_\'):\\n            releases.append((item, os.path.getctime(item)))\\n    releases.sort(key=lambda tup: tup[1], reverse=True)\\n    for release in releases[keep:]:\\n        print(\'removing {}\'.format(release[0]))\\n        shutil.rmtree(release[0])\\n\\nif __name__ == \'__main__\':\\n    if len(sys.argv) >= 2:\\n        try:\\n            keep = int(sys.argv[1])\\n            cleanup(keep)\\n        except ValueError:\\n            print(\'invalid parameter: {}\'.format(sys.argv[1]))\\n```\\n\\n```shell\\npython cleanup.py 10 # number of old versions to keep\\n```"},{"id":"/2018/07/09/angular-synchronize-properties-with-url-parameters","metadata":{"permalink":"/blog/2018/07/09/angular-synchronize-properties-with-url-parameters","source":"@site/blog/2018-07-09-angular-synchronize-properties-with-url-parameters/index.md","title":"Angular: Synchronize component properties with URL query parameters","description":"In some Angular applications the current route (or component if you will) holds an internal state of the application.","date":"2018-07-09T00:00:00.000Z","formattedDate":"July 9, 2018","tags":[{"label":"angular","permalink":"/blog/tags/angular"},{"label":"typescript","permalink":"/blog/tags/typescript"}],"readingTime":3.83,"hasTruncateMarker":false,"authors":[{"name":"Florian Mladitsch","title":"Software Developer","url":"https://github.com/flom","imageURL":"https://github.com/flom.png","key":"flom"}],"frontMatter":{"title":"Angular: Synchronize component properties with URL query parameters","authors":"flom","tags":["angular","typescript"]},"prevItem":{"title":"Poor Man\'s Zero Downtime Deployment in IIS","permalink":"/blog/2018/12/10/zero-downtime-iis-deployment"}},"content":"In some Angular applications the current route (or component if you will) holds an internal state of the application.\\nFor example a entered search term and/or selected item in a list.\\n\\n![Internal State](internal_state.PNG)\\n\\nWith a Angular component looking something like this:\\n\\n```typescript\\nimport { Component } from \'@angular/core\';\\n\\n@Component({\\n  selector: \'app-example-one\',\\n  templateUrl: \'./example-one.component.html\',\\n  styleUrls: [\'./example-one.component.css\']\\n})\\nexport class ExampleOneComponent {\\n  searchTerm = \'\';\\n  searchOption = 1;\\n}\\n```\\n\\nIn order to not lose the state when the user refreshes the page (or wants to bookmark/share it) the current state must be persisted somewhere.\\nWhile we could persist it in local storage (or session storage or cookie) this approach breaks when the user wants to share the link with another person.\\nInstead what some applications are doing is to store the state in the URL.\\nThe URL route/query parameters are updated as you change the state of a page.\\nOn good example for this is Google Maps where the current view is encoded into the URL automatically after you change the current view.\\n\\n[![Google Maps Example](google_maps_example.PNG)\\n\\nIn Angular what I\'m doing most of the time is to use the *<a href=\\"https://angular.io/api/router/ActivatedRoute\\" target=\\"_blank\\">ActivatedRoute</a>* service and update query parameters in the URL more less manually after the internal state changes.\\nAdditionally during component initialization I have to read the current query parameters in order to set my internal properties (states) at startup.\\n\\n```typescript\\nimport { Component, OnInit } from \'@angular/core\';\\nimport { ActivatedRoute, Router } from \'@angular/router\';\\n\\n@Component({\\n  selector: \'app-example-one\',\\n  templateUrl: \'./example-one.component.html\',\\n  styleUrls: [\'./example-one.component.css\']\\n})\\nexport class ExampleOneComponent implements OnInit {\\n  searchTerm = \'\';\\n  searchOption = 1;\\n\\n  constructor(private activatedRoute: ActivatedRoute, private router: Router) {\\n  }\\n\\n  ngOnInit() {\\n    if (this.activatedRoute.snapshot.queryParams[\'searchTerm\']) {\\n      this.searchTerm = this.activatedRoute.snapshot.queryParams[\'searchTerm\'];\\n    }\\n\\n    if (this.activatedRoute.snapshot.queryParams[\'searchOption\']) {\\n      this.searchOption = parseInt(this.activatedRoute.snapshot.queryParams[\'searchOption\'], 10);\\n    }\\n  }\\n\\n  syncQueryParams() {\\n    this.router.navigate([\'.\'], {\\n      relativeTo: this.activatedRoute,\\n      queryParams: {\\n        searchTerm: this.searchTerm,\\n        searchOption: this.searchOption\\n      }\\n    });\\n  }\\n}\\n```\\n\\nComponent template:\\n\\n```text\\n<div class=\\"form-group\\">\\n  <label class=\\"input-label\\">Search Term</label>\\n  <input type=\\"text\\" [(ngModel)]=\\"searchTerm\\" (ngModelChange)=\\"syncQueryParams()\\">\\n</div>\\n\\n<div class=\\"form-group\\">\\n  <label>\\n    Option 1\\n    <input type=\\"radio\\" name=\\"searchOption\\" [value]=\\"1\\" [(ngModel)]=\\"searchOption\\" (ngModelChange)=\\"syncQueryParams()\\">\\n  </label>\\n  <label>\\n    Option 2\\n    <input type=\\"radio\\" name=\\"searchOption\\" [value]=\\"2\\" [(ngModel)]=\\"searchOption\\" (ngModelChange)=\\"syncQueryParams()\\">\\n  </label>\\n</div>\\n```\\n\\nThis got me thinking if it possible and easier to use Typescript property decorators to mark those properties (that represent my internal state) and automatically synchronize the values with the URL.\\n\\nDocumentation about Typescript Decorator can be found here: <a href=\\"http://www.typescriptlang.org/docs/handbook/decorators.html\\" target=\\"_blank\\">TypeScript Decorator</a>\\n\\nI was hoping I could end up with something like the following code:\\n\\n```typescript\\nexport class ExampleTwoComponent {\\n  @UrlState() searchTerm = \'\';\\n  @UrlState() searchOption = 1;\\n}\\n```\\n\\nSo, whenever this component is initialized those two properties would be set when the URL contains ```?searchTerm=someSearch&searchOption=2``` and when I update the properties in the view it would reflect in the URL automatically.\\n\\nBut at this point I ran into the problem that it is not possible to directly inject (Angular) services into my decorator because they are, after all, just exported functions.\\nWhile it is completely possible to implement query parameter updates without *Router* and *ActivatedRoute* I opted for a different solution/hack I found on Stackoverflow[1] in order to inject services into a decorator.\\n\\nBasically what it does is to inject the service ```Injector``` into your component and then your decorator function taps into the ```ngOnInit``` method of the component to inject its required services.\\nThe complete implementations looks something like this:\\n\\n```typescript\\nexport class ExampleTwoComponent implements OnInit {\\n  @UrlState() searchTerm = \'\';\\n  @UrlState({\\n    parseFct: val => parseInt(val, 10)\\n  }) searchOption = 1;\\n\\n  constructor(public injector: Injector) {\\n  }\\n}\\n```\\n\\n```typescript\\nexport function UrlState(settings = {\\n  parseFct: val => val\\n}): PropertyDecorator {\\n  return function (target, propertyKey) {\\n    let propertyValue;\\n    let activatedRoute: ActivatedRoute;\\n    let router: Router;\\n\\n    const ngOnInitUnpatched = target[\'ngOnInit\'];\\n    target[\'ngOnInit\'] = function (this) {\\n      activatedRoute = this.injector.get(ActivatedRoute);\\n      router = this.injector.get(Router);\\n\\n      activatedRoute.queryParams\\n        .subscribe((params) => {\\n          if (params[propertyKey]) {\\n            target[propertyKey] = settings.parseFct(params[propertyKey]);\\n          }\\n        });\\n\\n      if (ngOnInitUnpatched) {\\n        return ngOnInitUnpatched.call(this);\\n      }\\n    };\\n\\n    function getter() {\\n      return propertyValue;\\n    }\\n\\n    function setter(value: any) {\\n      propertyValue = value;\\n      if (activatedRoute) {\\n        const newQueryParam = {};\\n        newQueryParam[propertyKey] = value;\\n\\n        router.navigate([\'.\'], {\\n          relativeTo: activatedRoute,\\n          queryParams: newQueryParam,\\n          queryParamsHandling: \'merge\',\\n          replaceUrl: true\\n        });\\n      }\\n    }\\n\\n    Object.defineProperty(target, propertyKey, {\\n      get: getter,\\n      set: setter,\\n      enumerable: true,\\n      configurable: true\\n    });\\n  };\\n}\\n```\\n\\nAdditionally, the decorator takes a (parser) function as parameter because when retrieving the value from the route it is returned as a string.\\nThe serialization/deserialization from and to query parameters could probably be done automatically in the decorator for primitive data types but this is just a quick and dirty proof of concept.\\nIt would be even possible to encode properties of type object into query parameters with those converter functions.\\n\\n---\\n\\n[1] <a href=\\"https://stackoverflow.com/questions/48873883/angular-aot-custom-decorator-error-encountered-resolving-symbol-values-staticall/48875749#48875749\\" target=\\"_blank\\">https://stackoverflow.com/questions/48873883/angular-aot-custom-decorator-error-encountered-resolving-symbol-values-staticall/48875749#48875749</a>\\n\\n<a href=\\"https://toddmotto.com/angular-decorators#creating-a-decorator\\" target=\\"_blank\\">https://toddmotto.com/angular-decorators#creating-a-decorator</a>"}]}')}}]);